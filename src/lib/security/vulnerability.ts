/**
 * TASK 182: VULNERABILITY MANAGEMENT
 *
 * Vulnerability tracking, prioritization, and remediation.
 */

import prisma from "@/lib/prisma";

export type RemediationStatus =
  | "OPEN"
  | "IN_PROGRESS"
  | "RESOLVED"
  | "ACCEPTED_RISK"
  | "FALSE_POSITIVE";

export interface Vulnerability {
  id: string;
  cve?: string;
  title: string;
  severity: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
  cvssScore: number;
  description: string;
  affectedAssets: string[];
  discoveredAt: Date;
  status: RemediationStatus;
  assignedTo?: string;
  dueDate?: Date;
  remediationSteps: string[];
}

export interface RemediationPlan {
  vulnerabilityId: string;
  priority: number;
  estimatedEffort: number;
  dependencies: string[];
  assignedTo: string;
  targetDate: Date;
}

/**
 * Create vulnerability
 */
export async function createVulnerability(data: {
  cve?: string;
  title: string;
  severity: Vulnerability["severity"];
  cvssScore: number;
  description: string;
  affectedAssets: string[];
  remediationSteps: string[];
}): Promise<string> {
  const vulnerability = await prisma.vulnerability.create({
    data: {
      ...data,
      affectedAssets: data.affectedAssets as any,
      remediationSteps: data.remediationSteps as any,
      discoveredAt: new Date(),
      status: "OPEN",
    } as any,
  });

  return vulnerability.id;
}

/**
 * Prioritize vulnerabilities
 */
export async function prioritizeVulnerabilities(): Promise<Vulnerability[]> {
  const vulnerabilities = await prisma.vulnerability.findMany({
    where: { status: { in: ["OPEN", "IN_PROGRESS"] } },
  });

  // Calculate priority score
  const scored = vulnerabilities.map((v) => {
    const severityWeight = {
      CRITICAL: 10,
      HIGH: 7,
      MEDIUM: 4,
      LOW: 1,
    }[v.severity];

    const ageWeight = Math.min(
      5,
      Math.floor((Date.now() - v.discoveredAt.getTime()) / (7 * 24 * 60 * 60 * 1000))
    );

    const assetWeight = (v.affectedAssets as string[]).length;

    const priority = severityWeight * 10 + ageWeight + assetWeight;

    return { ...v, priority };
  });

  return scored.sort((a, b) => b.priority - a.priority) as any;
}

/**
 * Assign vulnerability
 */
export async function assignVulnerability(
  vulnerabilityId: string,
  userId: string,
  dueDate?: Date
): Promise<void> {
  await prisma.vulnerability.update({
    where: { id: vulnerabilityId },
    data: {
      assignedTo: userId,
      dueDate,
      status: "IN_PROGRESS",
    } as any,
  });
}

/**
 * Update vulnerability status
 */
export async function updateVulnerabilityStatus(
  vulnerabilityId: string,
  status: RemediationStatus,
  notes?: string
): Promise<void> {
  await prisma.vulnerability.update({
    where: { id: vulnerabilityId },
    data: { status } as any,
  });

  // Create status change log
  await prisma.vulnerabilityStatusLog.create({
    data: {
      vulnerabilityId,
      status,
      notes,
      changedAt: new Date(),
    } as any,
  });
}

/**
 * Get remediation roadmap
 */
export async function getRemediationRoadmap(): Promise<{
  week1: Vulnerability[];
  week2: Vulnerability[];
  week3: Vulnerability[];
  week4: Vulnerability[];
  backlog: Vulnerability[];
}> {
  const prioritized = await prioritizeVulnerabilities();

  const now = Date.now();
  const week = 7 * 24 * 60 * 60 * 1000;

  return {
    week1: prioritized.slice(0, 5),
    week2: prioritized.slice(5, 10),
    week3: prioritized.slice(10, 15),
    week4: prioritized.slice(15, 20),
    backlog: prioritized.slice(20),
  };
}

/**
 * Get vulnerability trends
 */
export async function getVulnerabilityTrends(timeWindow: number = 90): Promise<{
  discovered: { date: Date; count: number }[];
  resolved: { date: Date; count: number }[];
  openCount: number;
  avgResolutionTime: number;
}> {
  const since = new Date(Date.now() - timeWindow * 24 * 60 * 60 * 1000);

  const vulnerabilities = await prisma.vulnerability.findMany({
    where: {
      OR: [{ discoveredAt: { gte: since } }, { status: "RESOLVED", updatedAt: { gte: since } }],
    },
  });

  // Group by date
  const discoveredMap = new Map<string, number>();
  const resolvedMap = new Map<string, number>();

  for (const vuln of vulnerabilities) {
    const discoveredDate = vuln.discoveredAt.toISOString().split("T")[0];
    discoveredMap.set(discoveredDate, (discoveredMap.get(discoveredDate) || 0) + 1);

    if (vuln.status === "RESOLVED" && vuln.updatedAt) {
      const resolvedDate = vuln.updatedAt.toISOString().split("T")[0];
      resolvedMap.set(resolvedDate, (resolvedMap.get(resolvedDate) || 0) + 1);
    }
  }

  const discovered = Array.from(discoveredMap.entries())
    .map(([date, count]) => ({ date: new Date(date), count }))
    .sort((a, b) => a.date.getTime() - b.date.getTime());

  const resolved = Array.from(resolvedMap.entries())
    .map(([date, count]) => ({ date: new Date(date), count }))
    .sort((a, b) => a.date.getTime() - b.date.getTime());

  const openCount = await prisma.vulnerability.count({
    where: { status: { in: ["OPEN", "IN_PROGRESS"] } },
  });

  // Calculate avg resolution time
  const resolvedVulns = await prisma.vulnerability.findMany({
    where: { status: "RESOLVED" },
    select: { discoveredAt: true, updatedAt: true },
  });

  const avgResolutionTime =
    resolvedVulns.length > 0
      ? resolvedVulns.reduce(
          (sum, v) => sum + (v.updatedAt!.getTime() - v.discoveredAt.getTime()),
          0
        ) /
        resolvedVulns.length /
        (24 * 60 * 60 * 1000)
      : 0;

  return {
    discovered,
    resolved,
    openCount,
    avgResolutionTime,
  };
}

/**
 * Get SLA compliance
 */
export async function getSLACompliance(): Promise<{
  compliant: number;
  breached: number;
  complianceRate: number;
}> {
  const vulnerabilities = await prisma.vulnerability.findMany({
    where: { dueDate: { not: null } },
  });

  let compliant = 0;
  let breached = 0;

  for (const vuln of vulnerabilities) {
    if (!vuln.dueDate) continue;

    if (vuln.status === "RESOLVED") {
      if (vuln.updatedAt && vuln.updatedAt <= vuln.dueDate) {
        compliant++;
      } else {
        breached++;
      }
    } else if (new Date() > vuln.dueDate) {
      breached++;
    }
  }

  const total = compliant + breached;
  const complianceRate = total > 0 ? (compliant / total) * 100 : 100;

  return { compliant, breached, complianceRate };
}

/**
 * Export vulnerability report
 */
export async function exportVulnerabilityReport(): Promise<any> {
  const vulnerabilities = await prisma.vulnerability.findMany();

  return {
    generatedAt: new Date(),
    totalVulnerabilities: vulnerabilities.length,
    bySeverity: {
      critical: vulnerabilities.filter((v) => v.severity === "CRITICAL").length,
      high: vulnerabilities.filter((v) => v.severity === "HIGH").length,
      medium: vulnerabilities.filter((v) => v.severity === "MEDIUM").length,
      low: vulnerabilities.filter((v) => v.severity === "LOW").length,
    },
    byStatus: {
      open: vulnerabilities.filter((v) => v.status === "OPEN").length,
      inProgress: vulnerabilities.filter((v) => v.status === "IN_PROGRESS").length,
      resolved: vulnerabilities.filter((v) => v.status === "RESOLVED").length,
    },
    vulnerabilities: vulnerabilities.map((v) => ({
      id: v.id,
      cve: v.cve,
      title: v.title,
      severity: v.severity,
      status: v.status,
      discoveredAt: v.discoveredAt,
    })),
  };
}
