// lib/intel/automation/executors/forensicWeather.ts
/**
 * ðŸ”¥ FORENSIC WEATHER EXECUTOR
 * Auto-generates legal-grade causation reports
 */

import { randomUUID } from "node:crypto";
import { logger } from "@/lib/logger";

import { buildMasterReportPayload } from "@/lib/intel/master/buildMasterPayload";
import { generateForensicWeatherReport } from "@/lib/intel/reports/forensic-weather";
import prisma from "@/lib/prisma";

export async function executeForensicWeather(claimId: string, orgId: string) {
  logger.debug(`[SKAI] Executing Forensic Weather for ${claimId}`);

  // Build master payload
  const payload = await buildMasterReportPayload({ claimId, orgId });
  const { claim, property, weatherReports, damageAssessments } = payload;

  const weatherReport = weatherReports[0];
  const damageAssessment = damageAssessments[0];
  const providerRaw = (weatherReport?.providerRaw as any) || {};

  // Generate forensic weather report
  const forensic = await generateForensicWeatherReport({
    claimId,
    weather: {
      dateOfLoss: claim.dateOfLoss.toISOString().split("T")[0],
      location: {
        lat: property?.latitude || 0,
        lon: property?.longitude || 0,
        address: property?.address || "",
      },
      timeline: {
        tenDaysBefore: [],
        dayOfEvent: providerRaw.timeline || [],
        fortyEightHoursAfter: [],
      },
      hail: {
        size: weatherReport?.primaryHazard || "Unknown",
        maxSize: parseFloat(weatherReport?.primaryHazard?.match(/[\d.]+/)?.[0] || "0"),
        probability: 0.85,
        impactAngle: 45,
      },
      wind: {
        gustSpeed: providerRaw.windGust || 0,
        sustainedSpeed: providerRaw.windSpeed || 0,
        direction: providerRaw.windDirection || 0,
        microburstDetected: false,
        tornadicActivity: false,
      },
      radar: {
        reflectivityMaps: [],
        velocityMaps: [],
        timestamps: [],
      },
      stormCell: {
        intensity: weatherReport?.globalSummary || "Moderate",
        movement: "Northeast",
        duration: 45,
        cellType: "Supercell",
      },
    },
    property: {
      address: property?.address || "",
      city: property?.city || "",
      state: property?.state || "",
      yearBuilt: property?.yearBuilt || 2000,
      roofAge: property?.roofAge || 10,
      roofSlope: property?.roofSlope || 6,
      roofOrientation: 180,
      materialType: property?.roofMaterial || "Architectural Shingles",
      structure: {
        stories: property?.stories || 2,
        roofType: "Gable",
        elevations: ["North", "South", "East", "West"],
        vulnerableAreas: ["Ridge", "Valleys"],
      },
    },
    damage: {
      locations: [],
      totalImpacts: 0,
      primaryPeril: damageAssessment?.primaryPeril || "hail",
      secondaryPeril: "wind",
    },
  });

  // Save to database
  const report = await prisma.ai_reports.create({
    data: {
      id: randomUUID(),
      orgId,
      claimId,
      type: "forensic_weather",
      title: `Forensic Weather - ${claim.claimNumber}`,
      prompt: "Auto-generated by SkaiPDF",
      content: JSON.stringify(forensic),
      model: "gpt-4o",
      userId: "skai",
      userName: "SkaiPDF",
      status: "generated",
      tokensUsed: 0,
      attachments: {
        correlationScore: forensic.damageCorrelation?.overallCorrelation || null,
      },
      updatedAt: new Date(),
    },
  });

  console.log(
    `[SKAI] Forensic Weather Generated - Correlation: ${forensic.damageCorrelation?.overallCorrelation || 0}`
  );

  return {
    reportId: report.id,
    correlationScore: forensic.damageCorrelation?.overallCorrelation || 0,
  };
}
