import { auth } from "@clerk/nextjs/server";
import { randomUUID } from "crypto";

import prisma from "@/lib/prisma";

export class MissingOrganizationError extends Error {
  constructor(message = "Organization not found for current user") {
    super(message);
    this.name = "MissingOrganizationError";
  }
}

interface OrgHelperOptions {
  requireOrg?: boolean; // if true and cannot bootstrap -> throw MissingOrganizationError
  bootstrapIfMissing?: boolean; // attempt auto-create if missing
}

// Core bootstrap (idempotent)
export async function getOrCreateOrgByClerkOrgId(
  clerkOrgId: string,
  name?: string | null
): Promise<{ Org: any; wasCreated: boolean }> {
  if (!clerkOrgId) throw new Error("Missing clerkOrgId");
  const existing = await prisma.org.findUnique({ where: { clerkOrgId } }).catch(() => null);
  if (existing) return { Org: existing, wasCreated: false };
  const created = await prisma.org.upsert({
    where: { clerkOrgId },
    update: {},
    create: {
      id: clerkOrgId.startsWith("org_") ? clerkOrgId : `org_${clerkOrgId}`,
      clerkOrgId,
      name: name || "My Company",
      updatedAt: new Date(),
    },
  });
  return { Org: created, wasCreated: true };
}

// Core bootstrap (idempotent)
export async function bootstrapNewOrgForUser(args: {
  clerkUserId: string;
  clerkOrgId?: string | null;
  email?: string | null;
  name?: string | null;
}): Promise<{ Org: any; wasCreated: boolean }> {
  const { clerkUserId, clerkOrgId, name } = args;
  const targetClerkOrgId = clerkOrgId || `org_${clerkUserId}`;
  const { Org: initialOrg, wasCreated } = await getOrCreateOrgByClerkOrgId(targetClerkOrgId, name);
  let Org = initialOrg;

  // Ensure membership exists in junction table user_organizations
  const membership = await prisma.user_organizations.findFirst({
    where: { userId: clerkUserId, organizationId: Org.id },
  });
  if (!membership) {
    try {
      await prisma.user_organizations.create({
        data: {
          id: randomUUID(),
          userId: clerkUserId,
          organizationId: Org.id,
          role: "ADMIN",
        } as any,
      });
    } catch {}
  }

  // Seed dependent singletons if missing (idempotent)
  try {
    const wallet = await prisma.tokenWallet.findUnique({ where: { orgId: Org.id } });
    if (!wallet) {
      await prisma.tokenWallet.create({
        data: {
          id: `tw_${Org.id}`,
          orgId: Org.id,
          aiRemaining: 0,
          dolCheckRemain: 0,
          dolFullRemain: 0,
          updatedAt: new Date(),
        },
      });
    }
  } catch {}
  try {
    const billing = await prisma.billingSettings.findUnique({ where: { orgId: Org.id } });
    if (!billing) {
      await prisma.billingSettings.create({
        data: {
          id: `bill_${Org.id}`,
          orgId: Org.id,
          autoRefill: false,
          refillThreshold: 10,
          updatedAt: new Date(),
        },
      });
    }
  } catch {}

  // Seed branding defaults (idempotent: only if missing)
  try {
    if (!Org.brandLogoUrl || !Org.pdfFooterText || !Org.pdfHeaderText) {
      const brandLogoUrl = Org.brandLogoUrl || "https://placehold.co/200x80?text=Logo";
      const pdfHeaderText = Org.pdfHeaderText || "PreLoss Vision Report";
      const pdfFooterText = Org.pdfFooterText || "Generated by PreLoss Vision";
      Org = await prisma.org.update({
        where: { id: Org.id },
        data: {
          brandLogoUrl,
          pdfHeaderText,
          pdfFooterText,
        },
      });
    }
  } catch {}

  return { Org, wasCreated };
}

export async function getOrCreateCurrentOrganization(
  options: OrgHelperOptions = {}
): Promise<any | null> {
  const { requireOrg = true, bootstrapIfMissing = true } = options;
  const { userId } = await auth();
  if (!userId) {
    if (requireOrg) return null;
    return null;
  }

  // lookup membership
  let membership = await prisma.user_organizations.findFirst({
    where: { userId: userId },
    select: { organizationId: true },
  });

  if (!membership && bootstrapIfMissing) {
    const { Org } = await bootstrapNewOrgForUser({ clerkUserId: userId });
    membership = { organizationId: Org.id } as any;
  }

  if (!membership) {
    if (requireOrg) throw new MissingOrganizationError();
    return null;
  }

  // fetch Org details
  const org = await prisma.org
    .findUnique({
      where: { id: (membership as any).orgId },
    })
    .catch(() => null);
  if (!org) {
    // Clean up orphaned membership before creating new org
    console.warn("[organizations] Cleaning up orphaned membership:", {
      userId,
      orphanedOrgId: (membership as any).orgId,
    });
    await prisma.user_organizations.deleteMany({
      where: { userId, organizationId: (membership as any).orgId },
    });

    if (bootstrapIfMissing) {
      const { Org: createdOrg } = await bootstrapNewOrgForUser({ clerkUserId: userId });
      return createdOrg;
    }
    if (requireOrg) throw new MissingOrganizationError();
    return null;
  }
  return org;
}
